#' For each row, gets the time before the next key
#'
#' This will not overwrite the current columns,
#' it will generate a separate one.
#'
#' @param chart The **data.frame** generated by f.chart.parse
#' @param ignore.lnotel A **logical** to determine if lnotel
#' should be included in the broadcasting
#'
#' @export

diff.broadcast <- function(chart,
                           ignore.types = c('lnotel')){

  require(magrittr)
  require(reshape2)
  require(Rfast)
  require(dplyr)

  Rcpp::sourceCpp("src/diff_broadcast.cpp")

  # Drop NA rows
  chart.bcst <- chart %>%

  # Ignores any types that matches the list
    filter(!(types %in% ignore.types)) %>%

    # As per the cpp function's requirements, the types
    # that we would want to participate is TRUE, while
    # the spectators are FALSE
    mutate(types = T) %>%

  # Cast keys to longer table.
    dcast(offsets ~ keys, value.var = 'types', fill = F) %>%

  # The plan is to flip the chart up-side down, then
  # we track different columns on the accumulated
  # offsets.
    arrange(desc(offsets))

  # Broadcast with cpp and assign back to the [2:] columns
  reset.columns <- 2:ncol(chart.bcst)
  chart.bcst[,reset.columns] <-
    cpp_broadcast(chart.bcst$offsets,
                  as.matrix(chart.bcst[,reset.columns]))

  chart.bcst %<>%
    # Merge to get back original type data
    merge(chart, by = 'offsets') %>%

    # Melt bcst columns to diffs
    melt(measure.vars = 2:ncol(chart.bcst),
         variable.name = 'keys.tos',
         value.name = 'diffs',
         na.rm = T) %>%

    # Rename for clarity
    rename(keys.froms = keys) %>%

    # Coerce to numeric
    mutate(keys.tos = as.numeric(keys.tos)) %>%

    # Remove invalid diffs
    filter(diffs > 0)

  return(chart.bcst)
}
